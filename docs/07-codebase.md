# 07 — Codebase Walkthrough

> alright, we've covered all the theory. now let's walk through this actual project, file by file, and see how everything we've learned comes together.

---

## project structure

```
echo-basics/
├── docs/                   # you are here
├── migrations/
│   └── migrations.go       # versioned DB migrations
├── models/
│   ├── context.go          # AppContext — carries DB through the request lifecycle
│   ├── enums.go            # FlagEnum type and constants
│   └── log.go              # Log model — maps to the logs table
├── modules/
│   ├── db.go               # opens the DB connection
│   ├── env.go              # loads .env files
│   └── utils.go            # GetLogLevel helper
├── routes/
│   ├── create.go           # POST /api/create
│   ├── detele.go           # DELETE /api/delete/:id (yes, typo in the filename, leave it)
│   ├── fetch.go            # GET /api/list, /fetch/i/:id, /fetch/t/:timestamp, /fetch/f/:flag
│   └── health.go           # GET /api/health
├── tests/
│   ├── create.sh
│   ├── delete.sh
│   ├── fetch_by_flag.sh
│   ├── fetch_by_id.sh
│   ├── health.sh
│   ├── list.sh
│   └── run_all.sh
├── server.go               # entry point — wires everything together
├── go.mod
├── go.sum
├── .gitignore
├── LICENSE
└── README.md
```

---

## server.go — the entry point

This is where everything starts. Let's go through it top to bottom.

```go
func main() {
    modules.LoadEnv("dev")
```

First thing we do is load environment variables from `.env` and `.dev.env` files. The `"dev"` argument tells the loader which env-specific file to look for. This means `.env` is always loaded, then `.env.dev` on top of it (if it exists). This is how you handle different configurations per environment without changing code.

```go
    limitRate, err := strconv.ParseFloat(os.Getenv("LIMIT_RATE"), 64)
    if err != nil {
        panic(err)
    }

    db := modules.InitDB()
```

We read `LIMIT_RATE` from the environment — this controls how many requests per second the rate limiter allows. Then we open the database connection. If `DSN` is missing or the connection fails, `InitDB` panics immediately. Better to know right away than to find out when the first request hits.

```go
    e := echo.New()
    e.Use(middleware.RequestLogger())
    e.Use(middleware.Secure())
    e.Use(middleware.RateLimiter(middleware.NewRateLimiterMemoryStore(limitRate)))
```

We create the Echo instance and wire up three global middleware:
- `RequestLogger` — logs every request with method, URI, status, latency
- `Secure` — adds security headers (XSS, content-type sniffing, clickjacking)
- `RateLimiter` — throttles requests in-memory per IP

```go
    if err := migrations.Run(db); err != nil {
        e.Logger.Error("migrations failed", "error", err)
    }
```

Migrations run before any routes are registered or requests are served. If they fail, we log the error but don't panic — the app still starts, and the migrations table will catch up on the next attempt.

```go
    e.Use(func(next echo.HandlerFunc) echo.HandlerFunc {
        return func(c *echo.Context) error {
            c.Set("app", &models.AppContext{DB: db})
            return next(c)
        }
    })
```

This is our context injection middleware. Every single request gets an `AppContext` attached to it under the `"app"` key. Any handler can then retrieve the database with `c.Get("app").(*models.AppContext).DB`. No globals, no dependency injection framework, just context.

```go
    api := e.Group("/api")
    api.Any("/health", routes.HealthCheck)
    api.POST("/create", routes.CreateLog)
    api.GET("/list", routes.FetchLogs)
    api.GET("/fetch/i/:id", routes.FetchID)
    api.GET("/fetch/t/:timestamp", routes.FetchTimestamp)
    api.GET("/fetch/f/:flag", routes.FetchFlag)
    api.DELETE("/delete/:id", routes.DeleteLog)
```

All API routes are grouped under `/api`. Each route maps to a handler function in the `routes` package. Clean and easy to read — you can see the entire API surface at a glance.

```go
    if err := e.Start(":" + os.Getenv("PORT")); err != nil {
        e.Logger.Error("Failed to start echo application", "error", err)
    }
```

Start the server on the port from the environment. If it fails (port already in use, etc.), log the error.

---

## models/

### models/log.go — the Log model

```go
type Log struct {
    ID        uuid.UUID `gorm:"primarykey;type:uuid;default:uuid_generate_v4()"`
    Flag      FlagEnum  `gorm:"type:log_flag"`
    Message   string    `gorm:"type:text;not null"`
    Timestamp time.Time `gorm:"default:CURRENT_TIMESTAMP"`
}
```

This struct maps directly to the `logs` table in Postgres. Every field has GORM tags that tell the ORM exactly what Postgres type to use and what defaults to apply.

- `ID` — UUID, generated by Postgres using `uuid_generate_v4()`. We don't set this in application code — the DB handles it.
- `Flag` — a `FlagEnum` type that maps to the Postgres `log_flag` enum. We normalize the value to lowercase before inserting.
- `Message` — plain text, required.
- `Timestamp` — set automatically by Postgres to the current time on insert. We don't set this in code either.

### models/enums.go — the FlagEnum

```go
type FlagEnum string

const (
    LogFlag   FlagEnum = "log"
    DebugFlag FlagEnum = "debug"
    InfoFlag  FlagEnum = "info"
    WarnFlag  FlagEnum = "warn"
    ErrorFlag FlagEnum = "error"
    TraceFlag FlagEnum = "trace"
)
```

`FlagEnum` is a typed alias for `string`. It gives us a named type with constants, which means:
- code that uses `models.InfoFlag` is more readable than `"info"`
- the compiler catches you if you pass a plain string where a `FlagEnum` is expected
- it maps cleanly to the Postgres `log_flag` enum via the GORM tag on the model

The values are lowercase because that's what the Postgres enum uses. Application code normalizes incoming input to lowercase before touching the DB.

### models/context.go — the AppContext

```go
type AppContext struct {
    DB *gorm.DB
}
```

A simple struct that holds app-wide dependencies. Right now that's just the database. As the application grows, you'd add things here — a cache client, a config struct, a logger — and they'd automatically be available in every handler through the same `c.Get("app")` pattern.

---

## modules/

### modules/db.go — database initialization

```go
func InitDB() *gorm.DB {
    if os.Getenv("DSN") == "" {
        panic("DSN environment variable is not set")
    }

    db, err := gorm.Open(postgres.New(postgres.Config{
        DSN:                  os.Getenv("DSN"),
        PreferSimpleProtocol: true,
    }), &gorm.Config{})

    if err != nil {
        panic("There exist a connection error, check logs manually: " + err.Error())
    }

    return db
}
```

Opens the database connection and returns a `*gorm.DB`. That's all it does. No schema changes, no AutoMigrate, nothing implicit. If the DSN is missing or the connection fails, it panics immediately — fail fast, fail loudly.

`PreferSimpleProtocol: true` disables prepared statements. Fine for development.

### modules/env.go — environment loader

```go
func LoadEnv(env string) error {
    envFiles := []string{
        ".env",
        ".env" + "." + env,
    }
    // reads each file and calls os.Setenv for each key=value line
}
```

A simple `.env` file loader. It reads `.env` first, then the environment-specific file (e.g. `.env.dev`). Lines starting with `#` are comments and are skipped. The `env` parameter controls which environment file to load on top of the base `.env`.

There's a `task:` comment in `server.go` about automating environment detection — right now `"dev"` is hardcoded. That's a good PR if you want one.

### modules/utils.go — GetLogLevel

```go
func GetLogLevel(flag models.FlagEnum) int {
    switch flag {
    case models.LogFlag:   return 0
    case models.DebugFlag: return 1
    case models.InfoFlag:  return 2
    case models.WarnFlag:  return 3
    case models.ErrorFlag: return 4
    case models.TraceFlag: return 5
    default:               return -1
    }
}
```

Maps a `FlagEnum` to a numeric severity level. This is used in the delete handler to enforce the rule: you can only delete logs with a flag level **below 4** — meaning `log`, `debug`, `info` and `warn`. `error` and `trace` are protected.

---

## routes/

### routes/health.go

```go
func HealthCheck(c *echo.Context) error {
    return c.JSON(http.StatusOK, map[string]interface{}{
        "status":  "ok",
        "message": "Yeppers, seems good.",
    })
}
```

The simplest handler in the project. Hit it, get a 200. Useful for load balancer health checks, uptime monitors, or just verifying the server is alive. Registered with `api.Any` so it responds to GET, POST, HEAD — whatever you throw at it.

---

### routes/create.go

```go
func CreateLog(c *echo.Context) error {
    db := c.Get("app").(*models.AppContext).DB
```

First thing every handler does — retrieve the database from the app context. If it's nil, return a 500 immediately. Defensive programming.

```go
    var payload struct {
        Flag    models.FlagEnum `json:"flag"`
        Message string          `json:"message" validate:"required"`
    }

    if err := c.Bind(&payload); err != nil {
        return c.JSON(http.StatusBadRequest, map[string]interface{}{
            "error": "bad request, i had better expectations from you.",
        })
    }
```

Bind the request body into an anonymous struct. We don't need a named type here — the struct is only used in this function. If binding fails (malformed JSON, wrong content type), return a 400.

```go
    flagStr := strings.ToLower(strings.TrimSpace(string(payload.Flag)))
    if flagStr == "" {
        flagStr = string(models.InfoFlag)
    }
```

Normalize the flag — trim whitespace, lowercase. If the flag wasn't provided at all, default to `"info"`.

```go
    allowed := map[string]struct{}{
        string(models.LogFlag):   {},
        string(models.DebugFlag): {},
        // ...
    }

    if _, ok := allowed[flagStr]; !ok {
        return c.JSON(http.StatusBadRequest, map[string]interface{}{"error": "invalid flag value"})
    }
```

Validate the flag against the allowed set. We use a `map[string]struct{}` for O(1) lookups — this is the idiomatic Go pattern for a set. If the flag isn't in the map, return a 400.

```go
    if err := db.WithContext(c.Request().Context()).Transaction(func(tx *gorm.DB) error {
        if err := tx.Create(&log).Error; err != nil {
            return err
        }
        return nil
    }); err != nil {
        return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
    }

    return c.JSON(http.StatusCreated, log)
```

Create the record inside a transaction. After a successful insert, GORM populates `log.ID` and `log.Timestamp` from the DB. Return the created record with a 201 status.

---

### routes/fetch.go

Four handlers in one file. They all follow the same pattern — get DB, validate input, query, return result.

**FetchLogs** — returns all logs. `Find` fetches all matching rows into a slice.

**FetchID** — parse the UUID path param, then use `First` to get exactly one record. `First` returns `gorm.ErrRecordNotFound` if nothing matches — we check for that specifically and return a 404.

**FetchTimestamp** — parse the path param as RFC3339 (we also try RFC3339Nano to be forgiving), then query for the latest log at or before that timestamp using `WHERE timestamp <= ? ORDER BY timestamp DESC LIMIT 1` (that's what `First` does with `Where` and `Order`).

**FetchFlag** — normalize and validate the flag param (same allowed-map pattern as create), then `Find` all logs with that flag ordered by timestamp descending.

---

### routes/detele.go — yes, the typo stays

```go
func DeleteLog(c *echo.Context) error {
    db := c.Get("app").(*models.AppContext).DB

    id, err := uuid.Parse(c.Param("id"))
    if err != nil {
        return c.JSON(http.StatusBadRequest, map[string]interface{}{
            "error": "bad request, i had better expectations from you.",
        })
    }

    var log models.Log = models.Log{ID: id}

    res := db.WithContext(c.Request().Context()).Find(&log)
    if res.Error != nil {
        // handle DB error / not found
    }

    if modules.GetLogLevel(log.Flag) < 4 {
        db.WithContext(c.Request().Context()).Delete(&log)
        return c.JSON(http.StatusOK, map[string]string{
            "message": "That record is long gone now. Don't worry, our secret is now safe.",
        })
    }

    return c.JSON(http.StatusForbidden, map[string]string{
        "error": "EEEEYYYY! You can't do that!",
    })
}
```

Parse the UUID, find the record, check its flag level using `GetLogLevel`. If the level is below 4 — delete it. If it's 4 or above (`error` or `trace`) — 403 Forbidden.

The delete rule is a business constraint enforced in application code: you can clean up low-severity logs, but you cannot delete errors or traces. Those are your audit trail.

---

## migrations/migrations.go

Covered in detail in [06 — Migrations](./06-migrations.md). In short: one migration, idempotent, creates the `uuid-ossp` extension, the `log_flag` enum type, and the `logs` table. Safe to run multiple times. Rollback reverses everything in the correct order.

---

## tests/

Seven shell scripts that use `curl` to smoke-test the API. No test frameworks, no dependencies — just `curl` and optionally `jq` for pretty output.

```sh
./tests/run_all.sh     # runs the full smoke test sequence
./tests/health.sh      # GET /api/health
./tests/create.sh      # POST /api/create
./tests/list.sh        # GET /api/list
./tests/fetch_by_flag.sh [FLAG]    # GET /api/fetch/f/:flag
./tests/fetch_by_id.sh [UUID]      # GET /api/fetch/i/:id
./tests/delete.sh [UUID]           # DELETE /api/delete/:id
```

`run_all.sh` chains them in order — health check, create a record, list all records, fetch by flag, fetch by ID, delete, list again to verify deletion. If `jq` is installed it extracts the created UUID automatically and passes it to the fetch and delete steps.

---

## things left to do (open PRs welcome)

There are intentional gaps in this codebase. Find them, fix them, open a PR. Here are some hints:

- `// task:` in `server.go` — the `"dev"` environment is hardcoded. It should be read from a `.env` file or an environment variable.
- paginated responses on `FetchLogs` and `FetchFlag` — right now they return everything. Add `limit` and `offset` query params.
- the delete handler has a `// task:` comment about making it atomic with `defer`, `DB.Begin()` and commit. Try it.
- `cmd/migrate` — a dedicated migration binary so you can run migrations separately from the app in CI/CD pipelines.
- proper validation middleware — `go-playground/validator` integrated with Echo for request validation.
- tests in Go — the curl scripts cover smoke testing but unit and integration tests in Go would be a proper addition.

---

→ next: [08 — API Reference](./08-api.md)

---

*MIT License — [devsimsek.mit-license.org](https://devsimsek.mit-license.org)*
